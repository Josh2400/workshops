{
  "hash": "8eecf4aec98478c957fa047b9429e9ea",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Extras - Iterative search\"\nsubtitle: \"Getting More Out of Feature Engineering and Tuning for Machine Learning\"\nformat:\n  revealjs: \n    slide-number: true\n    footer: <https://workshops.tidymodels.org>\n    include-before-body: header.html\n    include-after-body: footer-annotations.html\n    theme: [default, tidymodels.scss]\n    width: 1280\n    height: 720\nknitr:\n  opts_chunk: \n    echo: true\n    collapse: true\n    comment: \"#>\"\n    fig.path: \"figures/\"\n---\n\n\n\n\n\n\n\n## Startup!  ![](hexes/tidymodels.png){.absolute top=-20 right=0 width=\"64\" height=\"74.24\"} ![](hexes/probably.png){.absolute top=-20 right=64 width=\"64\" height=\"74.24\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidymodels)\nlibrary(important)\nlibrary(probably)\n\ntidymodels_prefer()\ntheme_set(theme_bw())\noptions(pillar.advice = FALSE, pillar.min_title_chars = Inf)\nmirai::daemons(parallel::detectCores())\n```\n:::\n\n\n\n## More startup! ![](hexes/rsample.png){.absolute top=-20 right=0 width=\"64\" height=\"74.24\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load our example data for this section\n\"https://raw.githubusercontent.com/tidymodels/\" |> \n  paste0(\"workshops/main/slides/class_data.RData\") |> \n  url() |> \n  load()\n\nset.seed(429)\nsim_split <- initial_split(class_data, prop = 0.75, strata = class)\nsim_train <- training(sim_split)\nsim_test  <- testing(sim_split)\n\nset.seed(523)\nsim_rs <- vfold_cv(sim_train, v = 10, strata = class)\n```\n:::\n\n\n\n## Neural network ![](hexes/tune.png){.absolute top=-20 right=0 width=\"64\" height=\"74.24\"} ![](hexes/recipes.png){.absolute top=-20 right=64 width=\"64\" height=\"74.24\"}\n\nFrom the seventh advanced slide deck:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnnet_spec <-\n  mlp(hidden_units = tune(), penalty = tune(), learn_rate = tune(),\n      epochs = 100, activation = tune()\n  ) |>\n  set_engine(\"brulee\", stop_iter = 10) |>\n  set_mode(\"classification\")\n\nrec <- \n  recipe(class ~ ., data = sim_train) |> \n  step_normalize(all_numeric_predictors())\n  \nthrsh_tlr <-\n  tailor() |>\n  adjust_probability_threshold(threshold = tune()) \n  \nnnet_wflow <- workflow(rec, nnet_spec, thrsh_tlr)\n\nnnet_param <-\n  nnet_wflow |> \n  extract_parameter_set_dials() |> \n  update(threshold = threshold(c(0.0001, 0.1)))\n  \ncls_mtr <- metric_set(brier_class, roc_auc, sensitivity, specificity)\n```\n:::\n\n\n\n## Iterative Search\n\nInstead of pre-defining a grid of candidate points, we can model our current results to predict what the next candidate point should be. \n\n<br>\n\nSuppose that we are only tuning the learning rate in our neural network. \n\n<br>\n\nWe could do something like: \n\n```r\nbrier_model <- lm(brier ~ learn_rate, data = resample_results)\n```\n\nand use this to predict and rank new learning rate candidates. \n\n\n## Iterative Search\n\nA linear model probably isn't the best choice though (more in a minute). \n\nTo illustrate the process, we resampled a large grid of learning rate values for our data to show what the relationship is between error and learning rate. \n\nNow suppose that we used a grid of three points in the parameter range for learning rate...\n\n\n## A Large Grid\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figures/grid-large-1.svg){fig-align='center' width=50%}\n:::\n:::\n\n\n\n\n## A Three Point Grid\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figures/grid-large-sampled-1.svg){fig-align='center' width=50%}\n:::\n:::\n\n\n\n## Gaussian Processes and Optimization  {.annotation}\n\nWe can make a \"meta-model\" with a small set of historical performance results. \n\n[Gaussian Processes](https://gaussianprocess.org/gpml/) (GP) models are a good choice to model performance. \n\n- It is a Bayesian model so we are using **Bayesian Optimization (BO)**.\n- For regression, we can assume that our data are multivariate normal. \n- We also define a _covariance_ function for the variance relationship between data points. A common one is:\n\n$$\\operatorname{cov}(\\boldsymbol{x}_i, \\boldsymbol{x}_j) = \\exp\\left(-\\frac{1}{2}|\\boldsymbol{x}_i - \\boldsymbol{x}_j|^2\\right) + \\sigma^2_{ij}$$\n\n\n:::notes\nGPs are good because \n\n- they are flexible regression models (in the sense that splines are flexible). \n- we need to get mean and variance predictions (and they are Bayesian)\n- their variability is based on spatial distances.\n\nSome people use random forests (with conformal variance estimates) or other methods but GPs are most popular.\n:::\n\n\n## Predicting Candidates\n\nThe GP model can take candidate tuning parameter combinations as inputs and make predictions for performance (e.g. Brier, ROC AUC, RMSE, etc.)\n\n - The _mean_ performance\n - The _variance_ of performance \n \nThe variance is mostly driven by spatial variability (the previous equation). \n\nThe predicted variance is zero at locations of actual data points and becomes very high when far away from any observed data. \n\n\n## Your turn {transition=\"slide-in\"}\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n*Your GP makes predictions on two new candidate tuning parameters.*  \n\n*We want to minimize error.* \n\n*Which should we choose?*\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](figures/two-candidates-1.svg){width=100%}\n:::\n:::\n\n\n:::\n\n::::\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"countdown\" id=\"mean-var-trade\" data-update-every=\"1\" tabindex=\"0\" style=\"bottom:0;left:0;\">\n<div class=\"countdown-controls\"><button class=\"countdown-bump-down\">&minus;</button><button class=\"countdown-bump-up\">&plus;</button></div>\n<code class=\"countdown-time\"><span class=\"countdown-digits minutes\">03</span><span class=\"countdown-digits colon\">:</span><span class=\"countdown-digits seconds\">00</span></code>\n</div>\n```\n\n:::\n:::\n\n\n\n\n## GP Fit (ribbon is mean +/- 1SD)\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figures/gp-iter-0-1.svg){fig-align='center' width=50%}\n:::\n:::\n\n\n\n\n## Choosing New Candidates\n\nThis isn't a very good fit but we can still use it.\n\nHow can we use the outputs to choose the next point to measure?\n\n<br> \n\n[_Acquisition functions_](https://ekamperi.github.io/machine%20learning/2021/06/11/acquisition-functions.html) take the predicted mean and variance and use them to balance: \n\n - _exploration_:  new candidates should explore new areas.\n - _exploitation_: new candidates must stay near existing values. \n\nExploration focuses on the variance, exploitation is about the mean. \n\n## Acquisition Functions\n\nWe'll use an acquisition function to select a new candidate.\n\nThe most popular method appears to be _expected improvement_ ([EI](https://arxiv.org/pdf/1911.12809.pdf)) above the current best results. \n \n  - Zero at existing data points. \n  - The _expected_ improvement is integrated over all possible improvement (\"expected\" in the probability sense). \n\nWe would probably pick the point with the largest EI as the next point. \n\n(There are other functions beyond EI.)\n\n## Expected Improvement\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figures/gp-iter-0-ei-1.svg){fig-align='center' width=50%}\n:::\n:::\n\n\n\n## Iteration\n\nOnce we pick the candidate point, we measure performance for it (e.g. resampling). \n\n<br> \n\nAnother GP is fit, EI is recomputed, and so on. \n\n<br> \n\nWe stop when we have completed the allowed number of iterations _or_ if we don't see any improvement after a pre-set number of attempts. \n\n\n## GP Fit with four points\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figures/gp-iter-1-1.svg){fig-align='center' width=50%}\n:::\n:::\n\n\n\n\n## Expected Improvement\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figures/gp-iter-1-ei-1.svg){fig-align='center' width=50%}\n:::\n:::\n\n\n\n::: {.absolute bottom=0 right=0}\n[AML4TD](https://aml4td.org/chapters/iterative-search.html#fig-bayes-opt), [TMwR](https://www.tmwr.org/iterative-search#bayesian-optimization)\n:::\n\n\n## BO in tidymodels\n\nWe'll use a function called `tune_bayes()` that has very similar syntax to `tune_grid()`. \n\n<br> \n\nIt has an additional `initial` argument for the initial set of performance estimates and parameter combinations for the GP model. \n\n## Initial grid points\n\n`initial` can be the results of another `tune_*()` function or an integer (in which case `tune_grid()` is used under to hood to make such an initial set of results).\n \n - We'll run the optimization more than once, so let's make an initial grid of results to serve as the substrate for the BO. \n\n - I suggest at least the number of tuning parameters plus two as the initial grid for BO. \n\n## Qualitative parameters\n\n- What about non-numeric tuning parameters such as `activation`?\n\n- _Currently_, tidymodels converts these to dummy indicators and uses those in the GP. This is not unusual but also not great. \n\t- Our initial grid should include more points; one for each _level_ of the qualitative parameter.\n\t- In our case, the activation function is preset to use 5 possible values. \n\n- An upcoming version of tune will use a different R package to fit the GP that uses _factor_ or _Gower kernels_. This will avoid making indicators and require fewer initial points.\n\n\n## An Initial Grid\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(12)\ninit_res <-\n  nnet_wflow |>\n  tune_grid(\n    resamples = sim_rs,\n    grid = nrow(nnet_param) + 6, # for activation values + 1 extra\n    param_info = nnet_param,\n    metrics = cls_mtr\n  )\n\nshow_best(init_res, metric = \"brier_class\", n = 3) |> select(-.metric, -.estimator)\n#> # A tibble: 3 × 9\n#>   hidden_units      penalty activation learn_rate threshold   mean     n std_err\n#>          <int>        <dbl> <chr>           <dbl>     <dbl>  <dbl> <int>   <dbl>\n#> 1           30 0.001        log_sigmo…     0.331     0.0101 0.0401    10 0.00236\n#> 2           40 0.0000000001 elu            0.0132    0.0600 0.0431    10 0.00183\n#> 3            6 0.0001       elu            0.0251    0.0800 0.0447    10 0.00280\n#> # ℹ 1 more variable: .config <chr>\n```\n:::\n\n\n\n## BO using tidymodels\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1|6,8-11|\"}\nctrl_bo <- control_bayes(verbose_iter = TRUE, no_improve = Inf) \n\nset.seed(125)\nnnet_bayes_res <-\n  nnet_wflow |>\n  tune_bayes(\n    resamples = sim_rs,\n    initial = init_res,     # <- initial results\n    iter = 25,\n    control = ctrl_bo,\n    param_info = nnet_param,\n    metrics = cls_mtr\n  )\n#> Optimizing brier_class using the expected improvement\n#> \n#> ── Iteration 1 ───────────────────────────────────────────────────────\n#> \n#> i Current best:\t\tbrier_class=0.04006 (@iter 0)\n#> i Gaussian process model\n#> i Generating 5000 candidates\n#> i Predicted candidates\n#> i hidden_units=11, penalty=1.13e-10, activation=log_sigmoid, learn_rate=0.36,\n#>   threshold=0.0678\n#> i Estimating performance\n#> ✓ Estimating performance\n#> ⓧ Newest results:\tbrier_class=0.05066 (+/-0.00346)\n#> \n#> ── Iteration 2 ───────────────────────────────────────────────────────\n#> \n#> i Current best:\t\tbrier_class=0.04006 (@iter 0)\n#> i Gaussian process model\n#> i Generating 5000 candidates\n#> i Predicted candidates\n#> i hidden_units=8, penalty=0.22, activation=tanh, learn_rate=0.0143,\n#>   threshold=0.0983\n#> i Estimating performance\n#> ✓ Estimating performance\n#> ⓧ Newest results:\tbrier_class=0.09955 (+/-0.000591)\n#> \n#> ── Iteration 3 ───────────────────────────────────────────────────────\n#> \n#> i Current best:\t\tbrier_class=0.04006 (@iter 0)\n#> i Gaussian process model\n#> i Generating 5000 candidates\n#> i Predicted candidates\n#> i hidden_units=15, penalty=3.26e-06, activation=log_sigmoid, learn_rate=0.62,\n#>   threshold=0.0729\n#> i Estimating performance\n#> ✓ Estimating performance\n#> ⓧ Newest results:\tbrier_class=0.05926 (+/-0.00613)\n#> \n#> ── Iteration 4 ───────────────────────────────────────────────────────\n#> \n#> i Current best:\t\tbrier_class=0.04006 (@iter 0)\n#> i Gaussian process model\n#> i Generating 5000 candidates\n#> i Predicted candidates\n#> i hidden_units=46, penalty=0.000214, activation=log_sigmoid,\n#>   learn_rate=0.537, threshold=0.0526\n#> i Estimating performance\n#> ✓ Estimating performance\n#> ⓧ Newest results:\tbrier_class=0.04446 (+/-0.00401)\n#> \n#> ── Iteration 5 ───────────────────────────────────────────────────────\n#> \n#> i Current best:\t\tbrier_class=0.04006 (@iter 0)\n#> i Gaussian process model\n#> i Generating 5000 candidates\n#> i Predicted candidates\n#> i hidden_units=46, penalty=0.287, activation=log_sigmoid, learn_rate=0.63,\n#>   threshold=0.0109\n#> i Estimating performance\n#> ✓ Estimating performance\n#> ⓧ Newest results:\tbrier_class=0.09951 (+/-0.000609)\n#> \n#> ── Iteration 6 ───────────────────────────────────────────────────────\n#> \n#> i Current best:\t\tbrier_class=0.04006 (@iter 0)\n#> i Gaussian process model\n#> i Generating 5000 candidates\n#> i Predicted candidates\n#> i hidden_units=9, penalty=0.00057, activation=elu, learn_rate=0.0486,\n#>   threshold=0.0268\n#> i Estimating performance\n#> ✓ Estimating performance\n#> ⓧ Newest results:\tbrier_class=0.04341 (+/-0.00331)\n#> \n#> ── Iteration 7 ───────────────────────────────────────────────────────\n#> \n#> i Current best:\t\tbrier_class=0.04006 (@iter 0)\n#> i Gaussian process model\n#> i Generating 5000 candidates\n#> i Predicted candidates\n#> i hidden_units=4, penalty=0.000623, activation=tanh, learn_rate=0.394,\n#>   threshold=0.0324\n#> i Estimating performance\n#> ✓ Estimating performance\n#> ⓧ Newest results:\tbrier_class=0.05986 (+/-0.00719)\n#> \n#> ── Iteration 8 ───────────────────────────────────────────────────────\n#> \n#> i Current best:\t\tbrier_class=0.04006 (@iter 0)\n#> i Gaussian process model\n#> i Generating 5000 candidates\n#> i Predicted candidates\n#> i hidden_units=21, penalty=1.15e-10, activation=tanh, learn_rate=0.00174,\n#>   threshold=0.0478\n#> i Estimating performance\n#> ✓ Estimating performance\n#> ⓧ Newest results:\tbrier_class=0.04676 (+/-0.0028)\n#> \n#> ── Iteration 9 ───────────────────────────────────────────────────────\n#> \n#> i Current best:\t\tbrier_class=0.04006 (@iter 0)\n#> i Gaussian process model\n#> i Generating 5000 candidates\n#> i Predicted candidates\n#> i hidden_units=14, penalty=0.00108, activation=relu, learn_rate=0.514,\n#>   threshold=0.0514\n#> i Estimating performance\n#> ✓ Estimating performance\n#> ⓧ Newest results:\tbrier_class=0.05046 (+/-0.00298)\n#> \n#> ── Iteration 10 ──────────────────────────────────────────────────────\n#> \n#> i Current best:\t\tbrier_class=0.04006 (@iter 0)\n#> i Gaussian process model\n#> i Generating 5000 candidates\n#> i Predicted candidates\n#> i hidden_units=28, penalty=0.000376, activation=elu, learn_rate=0.00663,\n#>   threshold=0.0603\n#> i Estimating performance\n#> ✓ Estimating performance\n#> ⓧ Newest results:\tbrier_class=0.04702 (+/-0.00472)\n#> \n#> ── Iteration 11 ──────────────────────────────────────────────────────\n#> \n#> i Current best:\t\tbrier_class=0.04006 (@iter 0)\n#> i Gaussian process model\n#> i Generating 5000 candidates\n#> i Predicted candidates\n#> i hidden_units=48, penalty=2.23e-10, activation=elu, learn_rate=0.00108,\n#>   threshold=0.0191\n#> i Estimating performance\n#> ✓ Estimating performance\n#> ⓧ Newest results:\tbrier_class=0.04567 (+/-0.00454)\n#> \n#> ── Iteration 12 ──────────────────────────────────────────────────────\n#> \n#> i Current best:\t\tbrier_class=0.04006 (@iter 0)\n#> i Gaussian process model\n#> i Generating 5000 candidates\n#> i Predicted candidates\n#> i hidden_units=7, penalty=8.08e-06, activation=tanh, learn_rate=0.00123,\n#>   threshold=0.011\n#> i Estimating performance\n#> ✓ Estimating performance\n#> ⓧ Newest results:\tbrier_class=0.04621 (+/-0.00301)\n#> \n#> ── Iteration 13 ──────────────────────────────────────────────────────\n#> \n#> i Current best:\t\tbrier_class=0.04006 (@iter 0)\n#> i Gaussian process model\n#> i Generating 5000 candidates\n#> i Predicted candidates\n#> i hidden_units=2, penalty=0.000753, activation=tanhshrink, learn_rate=0.536,\n#>   threshold=0.0769\n#> i Estimating performance\n#> ✓ Estimating performance\n#> Error in `purrr::map()`:\n#> ℹ In index: 5.\n#> Caused by error in `UseMethod()`:\n#> ! no applicable method for 'mutate' applied to an object of class \"NULL\"\n#> ✖ Optimization stopped prematurely; returning current results.\n```\n:::\n\n\n\n## Best results\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshow_best(nnet_bayes_res, metric = \"brier_class\") |> select(-.metric, -.estimator)\n#> # A tibble: 5 × 10\n#>   hidden_units      penalty activation learn_rate threshold   mean     n std_err\n#>          <int>        <dbl> <chr>           <dbl>     <dbl>  <dbl> <int>   <dbl>\n#> 1           30 0.001        log_sigmo…     0.331     0.0101 0.0401    10 0.00236\n#> 2           40 0.0000000001 elu            0.0132    0.0600 0.0431    10 0.00183\n#> 3            9 0.000570     elu            0.0486    0.0268 0.0434    10 0.00331\n#> 4           46 0.000214     log_sigmo…     0.537     0.0526 0.0445    10 0.00401\n#> 5            6 0.0001       elu            0.0251    0.0800 0.0447    10 0.00280\n#> # ℹ 2 more variables: .config <chr>, .iter <int>\n```\n:::\n\n\n\n\n## Plotting BO Results\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nautoplot(nnet_bayes_res, metric = \"brier_class\")\n```\n\n::: {.cell-output-display}\n![](figures/autoplot-marginals-1.svg){fig-align='center' width=50%}\n:::\n:::\n\n\n\n\n## Plotting BO Results\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nautoplot(nnet_bayes_res, metric = \"brier_class\", type = \"parameters\")\n```\n\n::: {.cell-output-display}\n![](figures/autoplot-param-1.svg){fig-align='center' width=50%}\n:::\n:::\n\n\n\n\n## Plotting BO Results\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nautoplot(nnet_bayes_res, metric = \"brier_class\", type = \"performance\")\n```\n\n::: {.cell-output-display}\n![](figures/autoplot-perf-1.svg){fig-align='center' width=50%}\n:::\n:::\n\n\n\n## Your turn {transition=\"slide-in\"}\n\n*Let's try a different acquisition function: `conf_bound(kappa)`.*\n\n*We'll use the `objective` argument to set it.*\n\n*Choose your own `kappa` value:*\n\n - *Larger values will explore the space more.* \n - *\"Large\" values are usually less than one.*\n\n**Bonus points**: Before the optimization is done, press `<esc>` and see what happens.\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"countdown\" id=\"conf-bound\" data-update-every=\"1\" tabindex=\"0\" style=\"right:0;bottom:0;\">\n<div class=\"countdown-controls\"><button class=\"countdown-bump-down\">&minus;</button><button class=\"countdown-bump-up\">&plus;</button></div>\n<code class=\"countdown-time\"><span class=\"countdown-digits minutes\">10</span><span class=\"countdown-digits colon\">:</span><span class=\"countdown-digits seconds\">00</span></code>\n</div>\n```\n\n:::\n:::\n\n\n\n## Notes\n\n- Stopping `tune_bayes()` will return the current results. \n\n- Parallel processing can still be used to more efficiently measure each candidate point. \n\n- There are [a lot of other iterative methods](https://github.com/topepo/Optimization-Methods-for-Tuning-Predictive-Models) that you can use. \n\n- The finetune package also has functions for [simulated annealing](https://www.tmwr.org/iterative-search.html#simulated-annealing) search. \n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../../site_libs/countdown-0.4.0/countdown.css\" rel=\"stylesheet\" />\n<script src=\"../../../site_libs/countdown-0.4.0/countdown.js\"></script>\n"
      ],
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}